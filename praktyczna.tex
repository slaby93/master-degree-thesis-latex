\chapter{Część praktyczna}
Cykl życia standardowej strony internetowej przedstawiono na rysunku \ref{fig:rysunek_7}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_7.png}
    \caption{Ilustracja przedstawiająca cykl życia statycznej strony internetowej}
    \label{fig:rysunek_7}
\end{figure}

\begin{itemize}
	\item Użytkownik otwiera przeglądarkę i odwiedza stronę WWW.
    \item Przeglądarka wysyła zapytanie do serwera z żądaniem zasobów.
    \item Serwer odsyła plik HTML w którym znajdują się odnośniki do plików JavaScript oraz CSS.
    \item Przeglądarka pobiera pliki JavaScript oraz CSS
    \item Przeglądarka renderuje stronę dla użytkownika.
    \item Użytkownik klika w odnośnik do kolejnej strony ( w przykładzie strona logowania)
    \item Przeglądarka pobiera cały nowy plik HTML
    \item Przeglądarka renderuje nową stronę od nowa.
    \item Przeglądarka ponownie pobiera dodatkowe pliki JavaScript oraz CSS (zakładamy, że przeglądarka nie przechowuje plików w pamięci podręcznej).
    \item Przeglądarka renderuje stronę od nowa.
\end{itemize}

Jak widzimy, cały proces odwiedzenia dwóch stron w tej samej domenie wymaga każdorazowego przeładowania strony oraz pobrania tych samych danych.
Proces ten wymaga ciągłego pobierania plików HTML, pobierania plików dodatkowych co obciąża procesor, pamięć łącze oraz sam serwer.

Dla porównania, przedstawiona poniżej ilustracja pokazuje cykl działania aplikacji SPA (rysunek \ref{fig:rysunek_8})

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_8.png}
    \caption{Ilustracja przedstawiająca cykl działania aplikacji SPA}
    \label{fig:rysunek_8}
\end{figure}

\begin{itemize}
    \item Użytkownik odwiedza tę samą stronę .
    \item Przeglądarka pobiera plik HTML z definicją potrzebnych zasobów. Zazwyczaj sekcja body pliku jest pusta.
    \item Przeglądarka pobiera dodatkowe pliki JavaScript oraz CSS.
    \item Często pliki te są zoptymalizowane poprzez kompresję i sklejone w jeden plik tak, aby wykonać tylko jedno zapytanie zamiast dwóch.
    \item Pliki JavaScript, generują treść strony HTML.
    \item Przeglądarka może ( ale nie musi ) wykonać dodatkowe zapytanie o dane do jednego z endpointów serwera.
    \item Użytkownik klika na odnośnik do kolejnej strony. Przeglądarka nie pobiera już dodatkowego pliku HTML, jako, że aplikacja jest dynamiczna. Skrypt JavaScript może, ale nie musi pobrać dodatkowych informacji z serwera.    
\end{itemize}

Jak widzimy, wykonano znacznie mniej zapytań do serwera. Dodatkowe zapytania które skrypt może wykonać w celu pobrania danych zazwyczaj są znacznie mniejsze od pełnego pliku HTML z wybraną treścią.
Dodatkowo, przeglądarka nie przeładowuje strony przy każdej zmianie podstrony, co także odciąża procesor jak i łącze sieciowe.

\section{Problem pomiaru wydajności aplikacji SPA}

Z racji, że w aplikacjach SPA nigdy nie następuje przeładowanie strony, a ich działanie jest ciągłe pojawia się problem następującej natury. 

W celu ułatwienia zrozumienia problemu posłużę się przykładem przedstawionym na rysunku \ref{fig:rysunek_9}. Załóżmy że jesteśmy na platformie Netflix. Otworzyliśmy stronę z listą dostępnych filmów do obejrzenia. 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_9.png}
    \caption{Grafika przedstawiająca mechanizm działania aplikacji dynamicznych}
    \label{fig:rysunek_9}
\end{figure}

Aplikacja w stanie początkowym nie posiada żadnych filmów. Użytkownik klika przycisk pobierz listę filmów. Efektem ubocznym (side effect)  jest wysłanie informacji o akcji do menedżera stanu.
Menedżer stanu wysyła zapytanie do serwera o listę filmów do zaproponowania. Serwer odpowiada z danymi, i menadżera stanu przechodzi w nowy stan.
Podstrona otrzymuje informacje o nowym stanie. Pobiera nowy stan z menedżera stanu i prze renderuje widok.


Problem pojawia się gdy chcemy określić kiedy cała procedura została zakończona.
Samo sprawdzenie czy przycisk został naciśnięty nie jest wystarczające, gdyż z perspektywy użytkownika, procedura obejmuje także rezultat efektu ubocznego.
Zapytanie do serwera zajmie od kilkudziesięciu milisekund do nawet i kilku czy kilkunastu sekund.
Samo renderowanie także nie jest deterministyczny w kontekście czasu operacji gdyż wpływ na nie mają inne usługi korzystające z procesora czy pamięci komputera.
Z racji, iż frameworki internetowe muszą być generyczne, nikomu jeszcze nie udało się stworzyć idealnego i jednolitego mechanizmu wyznaczania, czy dana akcja została zakończona czy nie.

Tak więc na potrzeby pracy istotnym jest, wprowadzenie jednoznacznej definicji akcji w aplikacji.

\emph{Akcja aplikacji - jest to zbiór procedur oraz zdarzeń i ich obsługi następujący w chwili interakcji użytkownika z aplikacją.}



\section{Specyfikacja wymagań}

\section{Architektura rozwiązania}
\subsection{Projekt testu wydajności}
\subsection{Budowa aplikacji}
\subsection{Przygotowanie aplikacji do badania}
\subsection{Konteneryzacja aplikacji}
\subsection{Moduł badania}
\subsection{Moduł analizy}

\section{Analiza wyników}
\subsection{Czas załadowania aplikacji}
\subsection{Dodanie 1000 wierszy na początku listy}
\subsection{Dodanie 1000 wierszy na końcu listy}
\subsection{Zamiana wszystkich wierszy na liście}
\subsection{Aktualizacja 500 wierszy}
\subsection{Zamiana miejscami dwóch wierszy}
\subsection{Usunięcie pojedynczego wiersza}
\subsection{Usunięcie wszystkich wierszy}



\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_10.png}
    \caption{Grafika przedstawiająca kolejność faz renderowania w przeglądarce}
    \label{fig:rysunek_10}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_11.png}
    \caption{Ilustracja przedstawiająca problem dopisywania elementu na koniec listy}
    \label{fig:rysunek_11}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_12.png}
    \caption{Ilustracja przedstawiająca problem dopisywania elementów na początek listy}
    \label{fig:rysunek_12}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_13.png}
    \caption{Ilustracja mechanizmu przebiegu badania}
    \label{fig:rysunek_13}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_14.png}
    \caption{Grafika przedstawiająca zaimplementowane przyciski w aplikacji}
    \label{fig:rysunek_14}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_15.png}
    \caption{Ilustracja procesu przygotowania aplikacji do konteneryzacji}
    \label{fig:rysunek_15}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_16.png}
    \caption{Ilustracja przedstawiająca warstwy składające się na  przykładowy obraz dockera}
    \label{fig:rysunek_16}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_17.png}
    \caption{Grafika przedstawiająca plik index.html wraz z dostępnymi aplikacjami do badania}
    \label{fig:rysunek_17}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_18.png}
    \caption{Ilustracja mechanizmu działania strony statycznej na przykładzie aplikacji kalendarza przy użyciu języka PHP}
    \label{fig:rysunek_18}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_19.png}
    \caption{Grafika przedstawiająca proces przeładowania strony statycznej}
    \label{fig:rysunek_19}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_20.png}
    \caption{Ilustracja procesu ładowania aplikacji oraz zdarzenia rejestrowane przez przeglądarkę}
    \label{fig:rysunek_20}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_21.png}
    \caption{Ilustracja mechanizmu zmiany daty w przypadku aplikacji dynamicznej}
    \label{fig:rysunek_21}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_22.png}
    \caption{Ilustracja przedstawiająca proces zmiany treści strony w przypadku aplikacji dynamicznej}
    \label{fig:rysunek_22}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_23.png}
    \caption{Ilustracja procesu współpracy pomiędzy Selenium a przeglądarką}
    \label{fig:rysunek_23}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_24.png}
    \caption{Wycinek wpisów skryptu przeprowadzającego badanie w środowisku docker-compose. Ilustruje on inicjalizację skryptu oraz mechanizm uzyskiwania połączenia pomiędzy Skryptem - Przeglądarką - Selenium}
    \label{fig:rysunek_24}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_25.png}
    \caption{Wycinek skryptu ukazujący uzyskanie połączenia do Selenium pomimo początkowych problemów}
    \label{fig:rysunek_25}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_26.png}
    \caption{Grafika przedstawia rozpoczęcie badania}
    \label{fig:rysunek_26}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_27.png}
    \caption{Grafika przedstawia skrypt zakańczający badanie po zapisaniu zebranych danych na dysk - widzimy, że ważnym elementem jest zamknięcie połączenia do Selenium}
    \label{fig:rysunek_27}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_28.png}
    \caption{Ilustracja struktury wyniku badania na które zostanie poddane dalszej obróbce}
    \label{fig:rysunek_28}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_29.png}
    \caption{Grafika przedstawiająca wpis zebranego pomiaru}
    \label{fig:rysunek_29}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_30.png}
    \caption{Diagram kolumnowy ukazujący wynik badania czasu potrzebnego do rozpoczęcia malowania strony}
    \label{fig:rysunek_30}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_31.png}
    \caption{Grafika ukazująca rozmiar plików zasobów dla aplikacji Angular2}
    \label{fig:rysunek_31}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_32.png}
    \caption{Grafika ukazująca rozmiar plików zasobów dla aplikacji React}
    \label{fig:rysunek_32}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_33.png}
    \caption{Grafika ukazująca rozmiar plików zasobów dla aplikacji Vue}
    \label{fig:rysunek_33}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_34.png}
    \caption{Diagram kolumnowy obrazujący wynik badania pomiaru czasu dodania 1000 elementów na początek listy}
    \label{fig:rysunek_34}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_35.png}
    \caption{Diagram kolumnowy obrazujący wynik badania pomiaru czasu dodania 1000 elementów na koniec listy}
    \label{fig:rysunek_35}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_36.png}
    \caption{Diagram kolumnowy obrazujący wynik badania pomiaru czasu zmiany wszystkich wartości listy dla 1000 elementów}
    \label{fig:rysunek_36}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_37.png}
    \caption{Diagram kolumnowy obrazujący wynik badania pomiaru czasu zmiany wartości dla 500 elementów listy}
    \label{fig:rysunek_37}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_38.png}
    \caption{Diagram kolumnowy obrazujący wynik badania pomiaru czasu zamiany miejscami dwóch wartości na liście elementów}
    \label{fig:rysunek_38}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_39.png}
    \caption{Diagram kolumnowy obrazujący wynik badania pomiaru czasu usunięcia pojedynczej wartości z listy elementów}
    \label{fig:rysunek_39}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=12cm]{rysunek_40.png}
    \caption{Diagram kolumnowy obrazujący wynik badania pomiaru czasu usunięcia wszystkich wartości z listy elementów}
    \label{fig:rysunek_40}
\end{figure}

%czyści puste strony
\let\cleardoublepage\clearpage